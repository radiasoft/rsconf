#!/bin/bash
set -euo pipefail

secondary_mirror_d='/srv/bkp/mirror'
secondary_copy_d='/bkp_copy'

secondary_assert_copy_d() {
    if [[ ! -d $secondary_copy_d ]]; then
        secondary_err "$secondary_copy_d does not exist"
    fi
    if [[ $(secondary_file_sys "$secondary_copy_d") == $(secondary_file_sys "$(dirname "$secondary_copy_d")") ]]; then
        secondary_err "$secondary_copy_d is not on a separate file system; need to run secondary_setup"
    fi
    if [[ $(ls $secondary_copy_d) ]]; then
        secondary_err "$secondary_copy_d is not empty"
    fi
}

secondary_err() {
    echo "$@" 1>&2
    return 1
}

secondary_file_sys() {
    declare file=$1
    declare x=( $(df "$file" | tail -1) )
    echo "${x[0]}"
}

secondary_main() {
    umask 077
    declare snap=$secondary_mirror_d/secondary_snap
    declare dst_d snap_d base_d copy_txz copy_tmp
    declare -i retries
    declare is_restart=
    if [[ -e $snap/RESTART ]]; then
        is_restart=1
        rm "$snap"/RESTART
        secondary_msg "Reusing snapshot $snap"
    else
        secondary_assert_copy_d
        rm -rf "$snap"
        cp -al '/bkp/mirror/current' "$snap"
    fi
    (
        # */* matches host.com/{var,etc,...} since these are
        # the first level to write
        cd "$snap" && find */* -type d -print0
    ) | while IFS= read -r -d $'\0' base_d; do
        if [[ ! $base_d =~ /.*/ ]]; then
            secondary_msg "Starting $base_d"
        fi
        snap_d=$snap/$base_d
        copy_d=$secondary_copy_d/$base_d
        copy_txz=$copy_d/0.txz
        copy_tmp=$copy_txz.tmp
        if [[ $base_d =~ srv/github_bkp/db/ ]]; then
            # the rsync (below) does all the work for sub directories
            continue
        elif [[ $base_d =~ srv/github_bkp/db$ ]]; then
            # github_bkp is already compressed so just copy
            # must be at this level to copy hard-links
            secondary_msg "Simple copy: $base_d"
            # handles restarts properly
            rsync -a --hard-links --sparse "$snap_d" "$(dirname "$copy_d")"
            continue
        fi
        mkdir -p "$copy_d"
        if [[ ! $(find "$snap_d" -maxdepth 1 ! -type d) ]]; then
            # empty directory
            continue
        fi
        if [[ $is_restart && -s $copy_txz ]]; then
            # Reusing $copy_txz if it is non-zero size
            rm -f "$copy_tmp"
            continue
        fi
        i=3
        while true; do
            if (
                # Just dump the file in to the dir since we aren't prefixing with the dir name
                # Ignore files with \ in them, because
                # tar: ./C:\Users
                # gold\Desktop\sweep1_a_1.mph: Cannot stat: No such file or directory
                # --text needed: since there are binary names to avoid:
                # Binary file (standard input) matches\n: Cannot stat: No such file or directory
                cd "$snap_d"
                find . -maxdepth 1 ! -type d -print0 \
                    | grep --text --null --null-data -v --perl-regexp '\\' \
                    | tar --create --null --files-from=- --file=-
            ) | pxz -T8 -9 > "$copy_tmp"; then
                mv "$copy_tmp" "$copy_txz"
                break
            fi
            rm -f "$copy_tmp"
            i+=-1
            if (( i < 0 )); then
                secondary_msg "FAILED COPY $copy_d, continuing"
                break
            fi
            sleep 60
            secondary_msg "Retrying $copy_d"
        done
    done
    chmod -R a-w "$secondary_copy_d"
    
}

secondary_msg() {
    echo "$@" 1>&2
}

secondary_main "$@"
