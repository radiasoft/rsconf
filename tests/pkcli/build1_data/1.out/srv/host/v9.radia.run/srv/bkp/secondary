#!/bin/bash
set -euo pipefail

_mirror_d='/srv/bkp/mirror'
_current_d='/srv/bkp/mirror/current'
_copy_d='/bkp_copy'
_snap_root_d=$_mirror_d/secondary_snap
_restart_f=$_snap_root_d/RESTART

_assert_copy_d() {
    if [[ ! -d $_copy_d ]]; then
        _err "$_copy_d does not exist"
    fi
    if [[ $(_file_sys "$_copy_d") == $(_file_sys "$(dirname "$_copy_d")") ]]; then
        _err "$_copy_d is not on a separate file system; need to run secondary_setup"
    fi
    if [[ $(ls $_copy_d) ]]; then
        _err "$_copy_d is not empty"
    fi
}

_err() {
    echo "$@" 1>&2
    return 1
}

_file_sys() {
    declare file=$1
    declare x=( $(df "$file" | tail -1) )
    echo "${x[0]}"
}

_main() {
    umask 077
    declare dst_d snap_d base_d copy_txz copy_tmp
    declare -i retries
    declare is_restart_rv=
    _snapshot
    (
        # */* matches host.com/{var,etc,...} since these are
        # the first level to write
        cd "$_snap_root_d" && find */* -type d -print0
    ) | while IFS= read -r -d $'\0' base_d; do
        if [[ ! $base_d =~ /.*/ ]]; then
            _msg "Starting $base_d"
        fi
        snap_d=$_snap/$base_d
        copy_d=$_copy_d/$base_d
        copy_txz=$copy_d/0.txz
        copy_tmp=$copy_txz.tmp
        if [[ $base_d =~ srv/github_bkp/db/ ]]; then
            # the rsync (below) does all the work for sub directories
            continue
        elif [[ $base_d =~ srv/github_bkp/db$ ]]; then
            # github_bkp is already compressed so just copy
            # must be at this level to copy hard-links
            _msg "Simple copy: $base_d"
            # handles restarts properly
            rsync -a --hard-links --sparse "$snap_d" "$(dirname "$copy_d")"
            continue
        fi
        mkdir -p "$copy_d"
        if [[ ! $(find "$snap_d" -maxdepth 1 ! -type d) ]]; then
            # empty directory
            continue
        fi
        if [[ $is_restart_rv && -s $copy_txz ]]; then
            # Reusing $copy_txz if it is non-zero size
            rm -f "$copy_tmp"
            continue
        fi
        i=3
        while true; do
            if (
                # Just dump the file in to the dir since we aren't prefixing with the dir name
                # Ignore files with \ in them, because
                # tar: ./C:\Users
                # gold\Desktop\sweep1_a_1.mph: Cannot stat: No such file or directory
                # --text needed: since there are binary names to avoid:
                # Binary file (standard input) matches\n: Cannot stat: No such file or directory
                cd "$snap_d"
                find . -maxdepth 1 ! -type d -print0 \
                    | grep --text --null --null-data -v --perl-regexp '\\' \
                    | tar --create --null --files-from=- --file=-
            ) | pxz -T8 -9 > "$copy_tmp"; then
                mv "$copy_tmp" "$copy_txz"
                break
            fi
            rm -f "$copy_tmp"
            i+=-1
            if (( i < 0 )); then
                _msg "FAILED COPY $copy_d, continuing"
                break
            fi
            sleep 60
            _msg "Retrying $copy_d"
        done
    done
    chmod -R a-w "$_copy_d"
    
}

_msg() {
    echo "$@" 1>&2
}

_snapshot() {
    if [[ -e $_restart_f ]]; then
        is_restart_rv=1
        rm "$_restart_f"
        _msg "Reusing snapshot $_snap_root_d"
        return
    fi
    if [[ -e $_snap_root_d ]] && (( $(date -u +%s) - $(stat -c %Y "$_snap_root_d") < 7 * 24 * 60 * 60 )); then
        _err "snapshot is too new, do one of:
A. rm -rf $_snap_root_d
B. touch $_restart_f
and
systemctl start bkp.service"
    fi
    rm -rf "$_snap_root_d"
    cp -al "$_current_d" "$_snap_root_d"
    touch "$_sentinel_f"
    _assert_copy_d
}

_main "$@"
